---
title: "Using ShinyLive"  
subtitle: "ST 437 Data Visualization"  
author:  
  - Erin Howard  
  - Brian Cervantes Alvarez  
date: today  
date-format: long  
format:  
    OSUstyle-html:  
        toc: true  
        toc-location: right  
        toc-depth: 5  
execute:  
  echo: true  
  warning: false  
  show-startup-message: false  
webr:  
  packages: ['ggplot2', 'dplyr', 'readr'] 
  show-startup-message: false  
filters:  
  - shinylive 
  - webr
---

## Introduction to Shiny & ShinyLive

Shiny allows you to make your plots interactive, adding widgets like sliders, dropdowns, and checkboxes that let users manipulate the plot in real-time.

A Shiny app is built around two main components:

1. **UI (User Interface)**: Defines how the app looks and what input controls are available to the user.
2. **Server**: Contains the instructions on how to generate and update outputs based on user inputs.

## Quick Guide to Installing `shinylive` for Quarto

### 1. Install `shinylive` R Package

In RStudio, install the `shinylive` package:

```r
install.packages("shinylive")
```

### 2. Create a Quarto Project

In the Terminal tab, create a new Quarto project:

```sh
quarto create project default
```

This sets up a Quarto project with a necessary `_quarto.yml` file.

### 3. Add `shinylive` Quarto Extension

Install the `shinylive` extension by running:

```sh
quarto add quarto-ext/shinylive
```

### 4. Embed a Shiny App in Your Quarto Document

Open your `.qmd` file and add the `shinylive` filter at the top:

```yaml
---
filters:
  - shinylive
---
```

Then, insert your Shiny app code in a code block like this:

```{shinylive-r}
#| standalone: true
#| components: [editor, viewer]

library(shiny)

ui <- fluidPage(
  sliderInput("obs", "Number of observations:", 1, 1000, 500),
  plotOutput("distPlot")
)

server <- function(input, output) {
  output$distPlot <- renderPlot({
    hist(rnorm(input$obs))
  })
}

shinyApp(ui, server)
```

### 5. Render Your Quarto Document

Render your document by clicking the Render button in RStudio or use:

```sh
quarto preview your-document.qmd --no-browser --no-watch-inputs
```

### 6. Publish Your Document (Optional)

To publish, use one of the following commands:

- **GitHub Pages**: `quarto publish gh-pages`
- **Quarto Pub**: `quarto publish quarto-pub`

## Important Considerations When Using ShinyLive

While ShinyLive allows you to run Shiny apps directly in a Quarto document, there are a few key quirks to be aware of:

1. **Library Inclusion**:
   - **Ensure all necessary libraries are included within the `{shinylive-r}` block**: If any required library is not loaded within the code block, the app will not run correctly when deployed on the web. This is because the web environment running the app does not have access to the R session in your local machine.

2. **Standalone Applications**:
   - **Use `#| standalone: true`**: This option should be included to indicate that the code represents a complete Shiny application. It ensures that all necessary components are included and isolated from other parts of the document.

3. **Component Configuration**:
   - **Configure components like `editor` and `viewer` properly**: These options allow users to interact with the code, making it easier to test and explore different configurations directly within the document.

4. **Resource Management**:
   - **Be mindful of resource-intensive operations**: Since the app runs in a web-based environment, heavy computations might slow down the app or cause it to become unresponsive. Use reactive programming efficiently to minimize unnecessary computations.



## Building our first shiny app


### Introduction to the Cost of Living Dataset

In this exercise, we’ll be using a dataset from **Numbeo**, a trusted source for comparing the cost of living across cities worldwide. The dataset compares various cost indices relative to New York City (NYC), which serves as the baseline with an index of 100%.

Here's an overview of the dataset:

| Column Name                         | Example Values                                     |
|-------------------------------------|----------------------------------------------------|
| **Rank**                            | 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...                 |
| **Country**                         | Switzerland, Bahamas, Iceland, Singapore, ...      |
| **Cost of Living Index**            | 101.1, 85.0, 83.0, 76.7, ...                       |
| **Rent Index**                      | 46.5, 36.7, 39.2, 67.2, ...                        |
| **Cost of Living Plus Rent Index**  | 74.9, 61.8, 62.0, 72.1, ...                        |
| **Groceries Index**                 | 109.1, 81.6, 88.4, 74.6, ...                       |
| **Restaurant Price Index**          | 97.0, 83.3, 86.8, 50.4, ...                        |
| **Local Purchasing Power Index**    | 158.7, 54.6, 120.3, 111.1, ...                     |

### Variables Explained

- **Cost of Living Index**: Compares the price of consumer goods (excluding rent) to NYC. An index of 120 means a city is 20% more expensive than NYC.

- **Rent Index**: Measures the cost of renting apartments compared to NYC. An index of 80 indicates rents are 20% cheaper than NYC.

- **Cost of Living Plus Rent Index**: Combines the Cost of Living Index and Rent Index for an overall comparison.

- **Groceries Index**: Reflects grocery prices relative to NYC.

- **Restaurant Price Index**: Compares the cost of dining out to NYC.

- **Local Purchasing Power Index**: Indicates the purchasing power of residents based on average net salary, relative to NYC.

For more details on the methodology, visit [Numbeo's methodology page](https://www.numbeo.com/common/motivation_and_methodology.jsp).

### Creating Skeleton `ggplot` Visualizations

In this step, we'll guide you through creating three basic `ggplot` visualizations to compare the **Cost of Living Index**, **Rent Index**, and **Groceries Index** for three selected countries. These plots will serve as the foundation for our Shiny app.

#### 1. Import the Dataset

First, we need to import the dataset that contains the cost of living data. The dataset is named `costOfLiving2024.csv` and should be stored in the your local directory.

**Instructions**:

1. Import the dataset using the `readr` package.

```{webr-r}
# Step 1: Load necessary libraries and import the dataset
library(ggplot2)
library(readr)
library(dplyr)

# cost_of_living <- read_csv("Assets/Datasets/costOfLiving2024.csv")

url <- "https://raw.githubusercontent.com/datasets/population/master/data/costOfLiving2024.csv"
download.file(url, "costOfLiving2024.csv")
cost_of_living <- read_csv("costOfLiving2024.csv")
# head(cost_of_living, 5)
```

2. The data is now stored in the `cost_of_living` variable and ready for analysis.

#### 2. Filter the Dataset

Next, let's filter the dataset to focus on three countries: **Switzerland**, **Singapore**, and **Iceland**.

**Instructions**:

1. Filter the dataset to include only these countries.

```{webr-r}
# Step 2: Filter the dataset for the selected countries
selected_countries <- c("Switzerland", "Singapore", "Iceland")
filtered_data <- cost_of_living %>%
  filter(Country %in% selected_countries)
```

2. This filtered dataset, `filtered_data`, will now only contain rows for the selected countries.

#### 3. Create a Skeleton `ggplot` for the Cost of Living Index

Now, let's create a basic column chart to visualize the **Cost of Living Index** for these countries.

**Instructions**:

1. Use `ggplot` to create a simple bar chart comparing the **Cost of Living Index**.

```{webr-r}
# Step 3: Skeleton plot for Cost of Living Index
ggplot(filtered_data, aes(x = Country, y = `Cost of Living Index`)) +
  geom_col() +
  labs(title = "Cost of Living Index Comparison",
       x = "Country",
       y = "Cost of Living Index")
```

2. This plot provides a visual comparison of the cost of living in the selected countries.

#### 4. Create a Skeleton `ggplot` for the Rent Index

Similarly, we can create another column chart to compare the **Rent Index**.

**Instructions**:

1. Use `ggplot` to visualize the **Rent Index** for the selected countries.

```{webr-r}
# Step 4: Skeleton plot for Rent Index
ggplot(filtered_data, aes(x = Country, y = `Rent Index`)) +
  geom_col() +
  labs(title = "Rent Index Comparison",
       x = "Country",
       y = "Rent Index")
```

2. This plot shows how rental costs vary across these countries.

#### 5. Create a Skeleton `ggplot` for the Groceries Index

Finally, let's create a chart for the **Groceries Index**.

**Instructions**:

1. Use `ggplot` to create a basic bar chart comparing the **Groceries Index**.

```{webr-r}
# Step 5: Skeleton plot for Groceries Index
ggplot(filtered_data, aes(x = Country, y = `Groceries Index`)) +
  geom_col() +
  labs(title = "Groceries Index Comparison",
       x = "Country",
       y = "Groceries Index")
```

2. This plot compares the cost of groceries in the selected countries.

### Summary

By completing this step, you now have the data imported and three skeleton `ggplot` visualizations that provide a basic comparison of the **Cost of Living Index**, **Rent Index**, and **Groceries Index** for Switzerland, Singapore, and Iceland. These plots are the building blocks for the interactive visualizations we’ll create in the following steps.

In the next step, we'll begin integrating these plots into a Shiny app, allowing users to interactively explore these indices for different countries.




## Shiny Demo | Distribution Sampling

Below is an example of a more advanced Shiny app embedded within a Quarto document, demonstrating the use of various inputs and dynamic UI elements.

:::{.column-screen}

```{shinylive-r}
#| standalone: true
#| viewerHeight: 650
#| components: [editor, viewer]

# Load necessary libraries
library(ggplot2)
library(dplyr)
library(shiny)
library(bslib)
library(colourpicker)

# Define UI for app that draws a histogram ----
ui <- page_sidebar(
  sidebar = sidebar(open = "open",
    numericInput("n", "Sample count", 100),
    selectInput("dist", "Distribution type",
      choices = c("Normal" = "norm", 
                  "Exponential" = "exp",
                  "Gamma" = "gamma",
                  "Uniform" = "unif",
                  "Beta" = "beta",
                  "Chi-squared" = "chisq",
                  "Log-normal" = "lnorm",
                  "F-distribution" = "f")),
    uiOutput("param_ui"),
    checkboxInput("animate", "Animate", FALSE),
    colourInput("hist_color", "Histogram Color", value = "lightcoral"),
    sliderInput("bins", "Number of Bins", min = 10, max = 100, value = 40, step = 1)
  ),
  plotOutput("plot", width = "100%", height = "600px")
)

server <- function(input, output, session) {
  output$param_ui <- renderUI({
    switch(input$dist,
      norm = tagList(
        sliderInput("mean", "Mean", min = -10, max = 10, value = 0, step = 0.1),
        sliderInput("sd", "Standard Deviation", min = 0.1, max = 10, value = 1, step = 0.1)
      ),
      exp = tagList(
        sliderInput("rate", "Rate (1/Mean)", min = 0.1, max = 10, value = 1, step = 0.1)
      ),
      gamma = tagList(
        sliderInput("shape", "Shape", min = 0.1, max = 10, value = 2, step = 0.1),
        sliderInput("scale", "Scale", min = 0.1, max = 10, value = 2, step = 0.1)
      ),
      unif = tagList(
        sliderInput("min", "Minimum", min = -10, max = 10, value = 0, step = 0.1),
        sliderInput("max", "Maximum", min = -10, max = 10, value = 1, step = 0.1)
      ),
      beta = tagList(
        sliderInput("alpha", "Alpha", min = 0.1, max = 10, value = 2, step = 0.1),
        sliderInput("beta", "Beta", min = 0.1, max = 10, value = 5, step = 0.1)
      ),
      chisq = tagList(
        sliderInput("df", "Degrees of Freedom", min = 1, max = 20, value = 2, step = 1)
      ),
      lnorm = tagList(
        sliderInput("meanlog", "Mean (log)", min = -5, max = 5, value = 0, step = 0.1),
        sliderInput("sdlog", "Standard Deviation (log)", min = 0.1, max = 2, value = 1, step = 0.1)
      ),
      f = tagList(
        sliderInput("df1", "Degrees of Freedom 1", min = 1, max = 20, value = 2, step = 1),
        sliderInput("df2", "Degrees of Freedom 2", min = 1, max = 20, value = 5, step = 1)
      )
    )
  })
  
  data <- reactive({
    if (isTRUE(input$animate)) {
      invalidateLater(1000)  # Default 1-second delay for fluid animation
    }
    
    n <- input$n
    dist <- input$dist
    
    switch(dist,
      norm = rnorm(n, mean = input$mean, sd = input$sd),
      exp = rexp(n, rate = input$rate),
      gamma = rgamma(n, shape = input$shape, scale = input$scale),
      unif = runif(n, min = input$min, max = input$max),
      beta = rbeta(n, shape1 = input$alpha, shape2 = input$beta),
      chisq = rchisq(n, df = input$df),
      lnorm = rlnorm(n, meanlog = input$meanlog, sdlog = input$sdlog),
      f = rf(n, df1 = input$df1, df2 = input$df2)
    )
  })
  
  output$plot <- renderPlot({
    hist_data <- data()
    dist_names <- c(
      norm = "Normal", exp = "Exponential", gamma = "Gamma", unif = "Uniform",
      beta = "Beta", chisq = "Chi-squared", lnorm = "Log-normal", f = "F-distribution"
    )
    dist_name <- dist_names[input$dist]
    
    ggplot(data.frame(x = hist_data), aes(x = x)) +
      geom_histogram(aes(y = ..density.., fill = "Histogram"), bins = input$bins, color = "black", alpha = 0.7) +
      stat_function(fun = switch(input$dist,
        norm = dnorm,
        exp = dexp,
        gamma = dgamma,
        unif = dunif,
        beta = dbeta,
        chisq = dchisq,
        lnorm = dlnorm,
        f = df
      ), args = switch(input$dist,
        norm = list(mean = input$mean, sd = input$sd),
        exp = list(rate = input$rate),
        gamma = list(shape = input$shape, scale = input$scale),
        unif = list(min = input$min, max = input$max),
        beta = list(shape1 = input$alpha, shape2 = input$beta),
        chisq = list(df = input$df),
        lnorm = list(meanlog = input$meanlog, sdlog = input$sdlog),
        f = list(df1 = input$df1, df2 = input$df2)
      ), aes(color = "Density Curve"), size = 1) +
      geom_vline(aes(xintercept = mean(hist_data), color = "Sample Mean"), linetype = "dotted", size = 1.2) +
      geom_vline(aes(xintercept = input$mean, color = "True Mean"), linetype = "dashed", size = 1.2) +
      scale_fill_manual(values = input$hist_color, name = "") +  # Use selected histogram color
      scale_color_manual(values = c("Density Curve" = "red", "Sample Mean" = "blue4", "True Mean" = "green4"), name = "") +
      labs(title = paste(dist_name, "Distribution | Random Sample"),
           x = "Value", y = "Density") +
      theme_minimal(base_size = 15) +
      theme(
        plot.title = element_text(hjust = 0.5),
        legend.position = "top",
        legend.title = element_blank()
      )
  }, res = 144)

  outputOptions(output, "plot", suspendWhenHidden = FALSE)
}

# Create Shiny app ----
shinyApp(ui = ui, server = server)
```

:::

---

### Additional Tips for Using ShinyLive

- **Testing Locally**: Before publishing or sharing your document, always test the Shiny app locally to ensure that it works as expected. This can help catch any issues related to missing libraries or improper configurations.
  
- **Resource Optimization**: If your Shiny app is performing slowly or struggling with large datasets, consider optimizing your code by reducing the number of reactive elements or pre-processing data where possible.

- **Error Handling**: Make sure to implement error handling within your Shiny app, especially when dealing with user inputs that could cause unexpected behavior.

By following these steps and keeping these considerations in mind, you'll be able to effectively embed and run Shiny applications within your Quarto documents using ShinyLive. This approach allows for a seamless integration of interactive elements into your reports and presentations, providing an engaging and dynamic experience for your audience.

