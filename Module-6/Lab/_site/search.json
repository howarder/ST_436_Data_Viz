[
  {
    "objectID": "SpatialViz.html",
    "href": "SpatialViz.html",
    "title": "Using Spatial Data",
    "section": "",
    "text": "Overview\nMapping geographic data helps us see patterns and trends in a way that’s easy to understand. This lab will guide you through creating different types of maps using R, followed by examples of interactive visualizations with Plotly and Shiny, and a step-by-step guide to building a static dashboard.\n\n\nPart 1 | Spatial Data Visualization\n\nExample 1 | Static Maps with ggplot2 and sf\nStatic maps are an essential tool when you need to present geographic information in a clear and concise manner. Unlike interactive maps, which allow users to explore data by zooming or clicking, static maps provide a snapshot of the data at a specific point in time. These maps are particularly useful in reports, presentations, or publications where you want to convey a specific message or highlight key patterns without requiring user interaction.\nIn this example, we’ll create a static map that visualizes global population data. By using population data from the World Bank, we’ll be able to show how the population is distributed across different countries. This type of visualization can help you easily identify regions with high or low population densities, making it easier to communicate insights in a report or presentation setting.\n\nStep 0 | Load the Necessary Libraries\nFirst, let’s load the libraries we need.\n\nlibrary(sf)                 # Handles spatial data and geometries in R using simple features\nlibrary(ggplot2)            # Creates data visualizations based on the grammar of graphics\nlibrary(dplyr)              # Provides tools for data manipulation and transformation\nlibrary(readr)              # Reads rectangular data, like CSV files, into R\nlibrary(leaflet)            # Creates interactive maps using the Leaflet JavaScript library\nlibrary(rnaturalearth)      # Accesses map data of countries and regions, suitable for visualization\nlibrary(rnaturalearthdata)  # Provides additional map data from Natural Earth\nlibrary(htmltools)          # Provides tools for generating HTML elements in R, often used in Shiny apps\n\n\n\nStep 1 | Load and Explore Spatial Data\nWe start by loading the global country boundaries and population data.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nStep 2 | Combine population.csv and world.sf\nNow, we’ll merge the population data with the world map based on the country codes.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nDataset we will be working with: world_pop_2021\nColumn Descriptions:\n\nCountry: The name of the country.\nCountryCode: The three-letter ISO code for the country.\nContinent: The continent where the country is located.\nPopulation: The total population of the country in the year 2021.\nYear: The year of the data collection, which is 2021.\nGDP: The Gross Domestic Product (GDP) of the country in million USD for the year 2021.\ngeometry: This contains the shapes and locations of countries on a map. Each country is represented by a MULTIPOLYGON, which is a set of polygons that outline the country’s borders. This is useful for countries with many islands or complex borders. The coordinates use the WGS 84 system, which is the standard for GPS and maps. Essentially, this column lets you visualize the countries on a map by storing the data that defines their shapes and locations.\n\n\n\n\nStep 3 | Basic Map Plotting\nTo visualize global population distribution using ggplot2, we leverage the geom_sf() function, which is designed to handle spatial data stored in the geometry column. First, we determine the most recent year in our dataset using max(world_pop_2021$Year) to ensure our map reflects the latest data. The geom_sf() function then plots the map, filling each country based on its population. The geometry column, which contains the shapes of countries, is crucial here as it allows geom_sf() to correctly position and draw each country on the map.\nWe use scale_fill_gradient() to apply a color gradient from white (lower population) to green (higher population), making it easier to see population differences. The population data is displayed in billions for clarity. The map’s title is dynamically updated with the latest year using paste(), ensuring the information is current. Lastly, we apply theme_minimal() to give the map a clean and simple appearance, which helps focus attention on the data.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nStep 4 | Filtering Specific Areas\n\nWhat if You Select a Specific Continent?\nWhen you filter the dataset to focus on a specific continent, such as \"North America\", the map might not display as expected. This could be due to the map’s default scaling, which may not appropriately zoom in on the region you’re interested in.\n\n\nFocusing on North America\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nWhat Happens to the Scale?\nWhen you select a specific continent, the default map scale might make certain regions appear distorted or improperly centered. This occurs because the default settings in ggplot2 are designed to accommodate a global view, and they may not automatically adjust when you narrow the focus to a specific continent.\n\n\nHow coord_sf() helps\nTo correct this, you can use the coord_sf() function, which allows you to manually set the longitude (xlim) and latitude (ylim) limits. By doing so, you can zoom in on the specific geographic area you’re interested in, ensuring the map is properly centered and displayed. Adjusting these values helps you focus the map on your continent of interest, making the visualization accurate and meaningful.\n\n\n\n\nExample 2 | Interactive Maps with leaflet\nInteractive maps let users explore data by zooming, panning, and clicking on different areas. We’ll use the leaflet package to make a map that you can interact with.\nHere’s how you can explain the code to your students, breaking down each step to ensure they understand how the leaflet package is used to create a simple interactive map:\n\nSimple leaflet Interactive Map\nCreating an interactive map in R is straightforward using the leaflet package. Let’s walk through a basic example where we’ll plot markers for two well-known cities: San Francisco and New York.\n\n# Create a basic interactive map\nm &lt;- leaflet() %&gt;%\n  addTiles() %&gt;%  # Add default map tiles\n  addMarkers(lng = c(-122.4194, -74.0060), lat = c(37.7749, 40.7128),\n             popup = c(\"San Francisco\", \"New York\"))\n\n# Display the map\nm\n\n\n\n\n\nExplanation:\n\nleaflet():\n\nThis line initializes a new leaflet map object. Think of it as creating a blank canvas where you can add various map features, like tiles, markers, and shapes.\nAt this point, the map is just an empty container with no visible content yet.\n\naddTiles():\n\nThis function adds the default map tiles to your leaflet object.\nMap tiles are the actual images that make up the background of your map (roads, terrain, etc.). By default, leaflet uses OpenStreetMap tiles, which are free and open-source.\nAdding tiles is like adding the background layer of the map so that you have something to visualize.\n\naddMarkers():\n\nMarkers are points on the map that indicate specific locations.\nlng and lat specify the longitude and latitude of the markers, respectively. In this case, we’re adding two markers:\n\n-122.4194, 37.7749 corresponds to San Francisco.\n-74.0060, 40.7128 corresponds to New York.\n\nThe popup argument defines the text that appears when you click on a marker. For each marker, a small window will pop up showing the name of the city (“San Francisco” or “New York”).\nThis step is like placing pins on a map to mark specific locations and labeling them.\n\n\n\n\nSummary\nThis simple example shows how easy it is to create an interactive map with leaflet in R. By initializing a map, adding a background layer (tiles), and placing markers, you can quickly visualize geographic data. This foundational knowledge will help you as you move on to more complex map visualizations, such as choropleth maps or maps with multiple layers of data.\n\n\n\nExample 2 | Interactive Choropleth Map with leaflet\nInteractive maps are a great way to explore data because they allow you to zoom in, pan around, and click on different areas to get more information. In this example, we’ll create an interactive map using the leaflet package to visualize global population and GDP data for the year 2021. Our map will show the population in billions or millions, depending on the country, and we’ll also display GDP in trillions, billions, or millions of USD.\n\nStep 1 | Prepare the Data\nBefore creating the map, we need to prepare our data. This involves making sure our population and GDP figures are correctly formatted so that they display in the appropriate units (trillions, billions, or millions).\n\n# url &lt;- \"https://raw.githubusercontent.com/datasets/population/master/data/world_population_2021.gpkg\"\n# download.file(url, \"world_population_2021.gpkg\")\n\nworld_pop_2021 &lt;- st_read(\"../../Assets/Datasets/world_population_2021.gpkg\")\n\nReading layer `world_population_2021' from data source \n  `/Users/briancervantesalvarez/Documents/VSCode Github/ST_437_Data_Viz/Assets/Datasets/world_population_2021.gpkg' \n  using driver `GPKG'\nSimple feature collection with 212 features and 6 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -180 ymin: -55.8917 xmax: 180 ymax: 83.59961\nGeodetic CRS:  WGS 84\n\n# world_pop_2021 &lt;- st_read(\"Assets/Datasets/world_population_2021.gpkg\")\nglimpse(world_pop_2021)\n\nRows: 212\nColumns: 7\n$ Country     &lt;chr&gt; \"Zimbabwe\", \"Zambia\", \"Yemen\", \"Vietnam\", \"Venezuela\", \"Va…\n$ CountryCode &lt;chr&gt; \"ZWE\", \"ZMB\", \"YEM\", \"VNM\", \"VEN\", \"VUT\", \"UZB\", \"URY\", \"F…\n$ Continent   &lt;chr&gt; \"Africa\", \"Africa\", \"Asia\", \"Asia\", \"South America\", \"Ocea…\n$ Population  &lt;dbl&gt; 15993524, 19473125, 32981641, 97468029, 28199867, 319137, …\n$ Year        &lt;dbl&gt; 2021, 2021, 2021, 2021, 2021, 2021, 2021, 2021, 2021, 2021…\n$ GDP         &lt;int&gt; 21440, 23309, 22581, 261921, 482359, 934, 57921, 56045, 40…\n$ geom        &lt;MULTIPOLYGON [°]&gt; MULTIPOLYGON (((31.28789 -2..., MULTIPOLYGON …\n\n# Convert population and GDP to trillions, billions, and millions\nworld_pop_2021 &lt;- world_pop_2021 %&gt;%\n  mutate(\n    PopulationBillions = Population / 1e9,  # Convert population to billions\n    PopulationMillions = Population / 1e6,  # Convert population to millions\n    GDPTrillions = GDP / 1e6,  # Convert GDP to trillions (since GDP is in millions)\n    GDPBillions = GDP / 1e3,    # Convert GDP to billions\n    GDPMillions = GDP           # GDP remains in millions\n  )\n\n# Create custom labels for population and GDP\nworld_pop_2021 &lt;- world_pop_2021 %&gt;%\n  mutate(\n    PopulationLabel = ifelse(\n      PopulationBillions &gt;= 1,\n      sprintf(\"%.2f B\", PopulationBillions),  # Use billions if population &gt;= 1 billion\n      sprintf(\"%.2f M\", PopulationMillions)   # Use millions if population &lt; 1 billion\n    ),\n    GDPLabel = case_when(\n      GDP &gt;= 1e6 ~ sprintf(\"%.2f T USD\", GDPTrillions),  # Use trillions if GDP &gt;= 1 trillion\n      GDP &gt;= 1e3 ~ sprintf(\"%.2f B USD\", GDPBillions),   # Use billions if GDP &gt;= 1 billion\n      TRUE       ~ sprintf(\"%.2f M USD\", GDPMillions)    # Use millions if GDP &lt; 1 billion\n    )\n  )\n\nExplanation:\n\nFiltering the Data: The filter(!is.na(Population)) line removes any countries from the dataset where population data is missing. This ensures that our map only includes countries with valid data.\nConverting Units: We then convert population data into billions and millions. GDP, originally in millions, is also converted into billions and trillions where appropriate. This makes it easier to display large numbers in a way that’s easy to read.\nCreating Labels: We use conditional statements to create labels. If a country’s population is over 1 billion, it’s displayed in billions; otherwise, it’s shown in millions. For GDP, we use trillions for values over 1 trillion, billions for values over 1 billion, and millions for smaller values.\n\n\n\n\nStep 2 | Create the Leaflet Map with Custom Labels\nNow that our data is ready, we can create the map. We’ll use leaflet to generate an interactive map that displays our custom labels when you hover over a country.\n\n# Create formatted labels with HTML for the hover-over information\nlabels &lt;- sprintf(\n  \"&lt;strong&gt;Country:&lt;/strong&gt; %s&lt;br/&gt;&lt;strong&gt;Population:&lt;/strong&gt; %s&lt;br/&gt;&lt;strong&gt;GDP:&lt;/strong&gt; %s&lt;br/&gt;&lt;strong&gt;Continent:&lt;/strong&gt; %s\",\n  world_pop_2021$Country,\n  world_pop_2021$PopulationLabel,\n  world_pop_2021$GDPLabel,\n  world_pop_2021$Continent\n) %&gt;% lapply(htmltools::HTML)\n\n\nlabels: We create labels that combine country name, population, GDP, and continent information. The sprintf() function is used to format these labels, and htmltools::HTML is applied to make sure the labels are properly displayed as HTML.\n\n\n# Create a leaflet map with enhanced hover-over information displayed vertically\n# Convert your data to an sf object (if it isn't already)\n\nm &lt;- leaflet(world_pop_2021) %&gt;%\n  addTiles() %&gt;%  # Add default map tiles\n  addPolygons(\n    fillColor = ~colorNumeric(\"YlGn\", PopulationBillions)(PopulationBillions),\n    weight = 1,\n    opacity = 1,\n    color = \"white\",\n    dashArray = \"3\",\n    fillOpacity = 0.7,\n    highlightOptions = highlightOptions(\n      weight = 3,\n      color = \"#666\",\n      dashArray = \"\",\n      fillOpacity = 0.7,\n      bringToFront = TRUE\n    ),\n    label = labels,\n    labelOptions = labelOptions(\n      style = list(\"font-weight\" = \"normal\", padding = \"3px 8px\"),\n      textsize = \"15px\",\n      direction = \"auto\"\n    )\n  ) %&gt;%\n  addLegend(\n    pal = colorNumeric(\"YlGn\", world_pop_2021$PopulationBillions),\n    values = ~PopulationBillions,\n    title = \"Population (Billions)\",\n    position = \"bottomright\"\n  )\n\nm\n\n\n\n\n\nExplanation:\n\naddTiles(): This function adds a base map layer, which is the visual background of the map (like streets, terrain, etc.).\naddPolygons(): This function adds the country borders to the map and fills them with color based on the population. It also includes settings for the label that pops up when you hover over a country, which we customized earlier.\naddLegend(): Finally, we add a legend to the map to explain the color coding. It shows what population values correspond to different shades of color.\n\n\nSummary\nThis exercise shows how to use the leaflet package to create interactive maps that display detailed information when you hover over different areas. By customizing the labels for population and GDP, we ensure the information is both accurate and easy to understand. Interactive maps like these are powerful tools for exploring geographic data and can make your data presentations more engaging and informative."
  },
  {
    "objectID": "ShinyViz.html",
    "href": "ShinyViz.html",
    "title": "Using ShinyLive",
    "section": "",
    "text": "Shiny allows you to make your plots interactive, adding widgets like sliders, dropdowns, and checkboxes that let users manipulate the plot in real-time.\nA Shiny app is built around two main components:\n\nUI (User Interface): Defines how the app looks and what input controls are available to the user.\nServer: Contains the instructions on how to generate and update outputs based on user inputs."
  },
  {
    "objectID": "ShinyViz.html#introduction-to-shiny-shinylive",
    "href": "ShinyViz.html#introduction-to-shiny-shinylive",
    "title": "Using ShinyLive",
    "section": "",
    "text": "Shiny allows you to make your plots interactive, adding widgets like sliders, dropdowns, and checkboxes that let users manipulate the plot in real-time.\nA Shiny app is built around two main components:\n\nUI (User Interface): Defines how the app looks and what input controls are available to the user.\nServer: Contains the instructions on how to generate and update outputs based on user inputs."
  },
  {
    "objectID": "ShinyViz.html#quick-guide-to-installing-shinylive-for-quarto",
    "href": "ShinyViz.html#quick-guide-to-installing-shinylive-for-quarto",
    "title": "Using ShinyLive",
    "section": "Quick Guide to Installing shinylive for Quarto",
    "text": "Quick Guide to Installing shinylive for Quarto\n\n1. Install shinylive R Package\nIn RStudio, install the shinylive package:\ninstall.packages(\"shinylive\")\n\n\n2. Create a Quarto Project\nIn the Terminal tab, create a new Quarto project:\nquarto create project default\nThis sets up a Quarto project with a necessary _quarto.yml file.\n\n\n3. Add shinylive Quarto Extension\nInstall the shinylive extension by running:\nquarto add quarto-ext/shinylive\n\n\n4. Embed a Shiny App in Your Quarto Document\nOpen your .qmd file and add the shinylive filter at the top:\n---\nfilters:\n  - shinylive\n---\nThen, insert your Shiny app code in a code block like this:\n#| standalone: true\n#| components: [editor, viewer]\n\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  sliderInput(\"obs\", \"Number of observations:\", 1, 1000, 500),\n  plotOutput(\"distPlot\")\n)\n\nserver &lt;- function(input, output) {\n  output$distPlot &lt;- renderPlot({\n    hist(rnorm(input$obs))\n  })\n}\n\nshinyApp(ui, server)\n\n\n5. Render Your Quarto Document\nRender your document by clicking the Render button in RStudio or use:\nquarto preview your-document.qmd --no-browser --no-watch-inputs\n\n\n6. Publish Your Document (Optional)\nTo publish, use one of the following commands:\n\nGitHub Pages: quarto publish gh-pages\nQuarto Pub: quarto publish quarto-pub"
  },
  {
    "objectID": "ShinyViz.html#important-considerations-when-using-shinylive",
    "href": "ShinyViz.html#important-considerations-when-using-shinylive",
    "title": "Using ShinyLive",
    "section": "Important Considerations When Using ShinyLive",
    "text": "Important Considerations When Using ShinyLive\nWhile ShinyLive allows you to run Shiny apps directly in a Quarto document, there are a few key quirks to be aware of:\n\nLibrary Inclusion:\n\nEnsure all necessary libraries are included within the {shinylive-r} block: If any required library is not loaded within the code block, the app will not run correctly when deployed on the web. This is because the web environment running the app does not have access to the R session in your local machine.\n\nStandalone Applications:\n\nUse #| standalone: true: This option should be included to indicate that the code represents a complete Shiny application. It ensures that all necessary components are included and isolated from other parts of the document.\n\nComponent Configuration:\n\nConfigure components like editor and viewer properly: These options allow users to interact with the code, making it easier to test and explore different configurations directly within the document.\n\nResource Management:\n\nBe mindful of resource-intensive operations: Since the app runs in a web-based environment, heavy computations might slow down the app or cause it to become unresponsive. Use reactive programming efficiently to minimize unnecessary computations."
  },
  {
    "objectID": "ShinyViz.html#building-our-first-shiny-app",
    "href": "ShinyViz.html#building-our-first-shiny-app",
    "title": "Using ShinyLive",
    "section": "Building our first shiny app",
    "text": "Building our first shiny app\n\nIntroduction to the Cost of Living Dataset\nIn this exercise, we’ll be using a dataset from Numbeo, a trusted source for comparing the cost of living across cities worldwide. The dataset compares various cost indices relative to New York City (NYC), which serves as the baseline with an index of 100%.\nHere’s an overview of the dataset:\n\n\n\n\n\n\n\nColumn Name\nExample Values\n\n\n\n\nRank\n1, 2, 3, 4, 5, 6, 7, 8, 9, 10, …\n\n\nCountry\nSwitzerland, Bahamas, Iceland, Singapore, …\n\n\nCost of Living Index\n101.1, 85.0, 83.0, 76.7, …\n\n\nRent Index\n46.5, 36.7, 39.2, 67.2, …\n\n\nCost of Living Plus Rent Index\n74.9, 61.8, 62.0, 72.1, …\n\n\nGroceries Index\n109.1, 81.6, 88.4, 74.6, …\n\n\nRestaurant Price Index\n97.0, 83.3, 86.8, 50.4, …\n\n\nLocal Purchasing Power Index\n158.7, 54.6, 120.3, 111.1, …\n\n\n\n\n\nVariables Explained\n\nCost of Living Index: Compares the price of consumer goods (excluding rent) to NYC. An index of 120 means a city is 20% more expensive than NYC.\nRent Index: Measures the cost of renting apartments compared to NYC. An index of 80 indicates rents are 20% cheaper than NYC.\nCost of Living Plus Rent Index: Combines the Cost of Living Index and Rent Index for an overall comparison.\nGroceries Index: Reflects grocery prices relative to NYC.\nRestaurant Price Index: Compares the cost of dining out to NYC.\nLocal Purchasing Power Index: Indicates the purchasing power of residents based on average net salary, relative to NYC.\n\nFor more details on the methodology, visit Numbeo’s methodology page.\n\n\nCreating Skeleton ggplot Visualizations\nIn this step, we’ll guide you through creating three basic ggplot visualizations to compare the Cost of Living Index, Rent Index, and Groceries Index for three selected countries. These plots will serve as the foundation for our Shiny app.\n\n1. Import the Dataset\nFirst, we need to import the dataset that contains the cost of living data. The dataset is named costOfLiving2024.csv and should be stored in the your local directory.\nInstructions:\n\nImport the dataset using the readr package.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nThe data is now stored in the cost_of_living variable and ready for analysis.\n\n\n\n2. Filter the Dataset\nNext, let’s filter the dataset to focus on three countries: Switzerland, Singapore, and Iceland.\nInstructions:\n\nFilter the dataset to include only these countries.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nThis filtered dataset, filtered_data, will now only contain rows for the selected countries.\n\n\n\n3. Create a Skeleton ggplot for the Cost of Living Index\nNow, let’s create a basic column chart to visualize the Cost of Living Index for these countries.\nInstructions:\n\nUse ggplot to create a simple bar chart comparing the Cost of Living Index.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nThis plot provides a visual comparison of the cost of living in the selected countries.\n\n\n\n4. Create a Skeleton ggplot for the Rent Index\nSimilarly, we can create another column chart to compare the Rent Index.\nInstructions:\n\nUse ggplot to visualize the Rent Index for the selected countries.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nThis plot shows how rental costs vary across these countries.\n\n\n\n5. Create a Skeleton ggplot for the Groceries Index\nFinally, let’s create a chart for the Groceries Index.\nInstructions:\n\nUse ggplot to create a basic bar chart comparing the Groceries Index.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nThis plot compares the cost of groceries in the selected countries.\n\n\n\n\nSummary\nBy completing this step, you now have the data imported and three skeleton ggplot visualizations that provide a basic comparison of the Cost of Living Index, Rent Index, and Groceries Index for Switzerland, Singapore, and Iceland. These plots are the building blocks for the interactive visualizations we’ll create in the following steps.\nIn the next step, we’ll begin integrating these plots into a Shiny app, allowing users to interactively explore these indices for different countries."
  },
  {
    "objectID": "ShinyViz.html#shiny-demo-distribution-sampling",
    "href": "ShinyViz.html#shiny-demo-distribution-sampling",
    "title": "Using ShinyLive",
    "section": "Shiny Demo | Distribution Sampling",
    "text": "Shiny Demo | Distribution Sampling\nBelow is an example of a more advanced Shiny app embedded within a Quarto document, demonstrating the use of various inputs and dynamic UI elements.\n\n#| standalone: true\n#| viewerHeight: 650\n#| components: [editor, viewer]\n\n# Load necessary libraries\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(shiny)\nlibrary(bslib)\nlibrary(colourpicker)\n\n# Define UI for app that draws a histogram ----\nui &lt;- page_sidebar(\n  sidebar = sidebar(open = \"open\",\n    numericInput(\"n\", \"Sample count\", 100),\n    selectInput(\"dist\", \"Distribution type\",\n      choices = c(\"Normal\" = \"norm\", \n                  \"Exponential\" = \"exp\",\n                  \"Gamma\" = \"gamma\",\n                  \"Uniform\" = \"unif\",\n                  \"Beta\" = \"beta\",\n                  \"Chi-squared\" = \"chisq\",\n                  \"Log-normal\" = \"lnorm\",\n                  \"F-distribution\" = \"f\")),\n    uiOutput(\"param_ui\"),\n    checkboxInput(\"animate\", \"Animate\", FALSE),\n    colourInput(\"hist_color\", \"Histogram Color\", value = \"lightcoral\"),\n    sliderInput(\"bins\", \"Number of Bins\", min = 10, max = 100, value = 40, step = 1)\n  ),\n  plotOutput(\"plot\", width = \"100%\", height = \"600px\")\n)\n\nserver &lt;- function(input, output, session) {\n  output$param_ui &lt;- renderUI({\n    switch(input$dist,\n      norm = tagList(\n        sliderInput(\"mean\", \"Mean\", min = -10, max = 10, value = 0, step = 0.1),\n        sliderInput(\"sd\", \"Standard Deviation\", min = 0.1, max = 10, value = 1, step = 0.1)\n      ),\n      exp = tagList(\n        sliderInput(\"rate\", \"Rate (1/Mean)\", min = 0.1, max = 10, value = 1, step = 0.1)\n      ),\n      gamma = tagList(\n        sliderInput(\"shape\", \"Shape\", min = 0.1, max = 10, value = 2, step = 0.1),\n        sliderInput(\"scale\", \"Scale\", min = 0.1, max = 10, value = 2, step = 0.1)\n      ),\n      unif = tagList(\n        sliderInput(\"min\", \"Minimum\", min = -10, max = 10, value = 0, step = 0.1),\n        sliderInput(\"max\", \"Maximum\", min = -10, max = 10, value = 1, step = 0.1)\n      ),\n      beta = tagList(\n        sliderInput(\"alpha\", \"Alpha\", min = 0.1, max = 10, value = 2, step = 0.1),\n        sliderInput(\"beta\", \"Beta\", min = 0.1, max = 10, value = 5, step = 0.1)\n      ),\n      chisq = tagList(\n        sliderInput(\"df\", \"Degrees of Freedom\", min = 1, max = 20, value = 2, step = 1)\n      ),\n      lnorm = tagList(\n        sliderInput(\"meanlog\", \"Mean (log)\", min = -5, max = 5, value = 0, step = 0.1),\n        sliderInput(\"sdlog\", \"Standard Deviation (log)\", min = 0.1, max = 2, value = 1, step = 0.1)\n      ),\n      f = tagList(\n        sliderInput(\"df1\", \"Degrees of Freedom 1\", min = 1, max = 20, value = 2, step = 1),\n        sliderInput(\"df2\", \"Degrees of Freedom 2\", min = 1, max = 20, value = 5, step = 1)\n      )\n    )\n  })\n  \n  data &lt;- reactive({\n    if (isTRUE(input$animate)) {\n      invalidateLater(1000)  # Default 1-second delay for fluid animation\n    }\n    \n    n &lt;- input$n\n    dist &lt;- input$dist\n    \n    switch(dist,\n      norm = rnorm(n, mean = input$mean, sd = input$sd),\n      exp = rexp(n, rate = input$rate),\n      gamma = rgamma(n, shape = input$shape, scale = input$scale),\n      unif = runif(n, min = input$min, max = input$max),\n      beta = rbeta(n, shape1 = input$alpha, shape2 = input$beta),\n      chisq = rchisq(n, df = input$df),\n      lnorm = rlnorm(n, meanlog = input$meanlog, sdlog = input$sdlog),\n      f = rf(n, df1 = input$df1, df2 = input$df2)\n    )\n  })\n  \n  output$plot &lt;- renderPlot({\n    hist_data &lt;- data()\n    dist_names &lt;- c(\n      norm = \"Normal\", exp = \"Exponential\", gamma = \"Gamma\", unif = \"Uniform\",\n      beta = \"Beta\", chisq = \"Chi-squared\", lnorm = \"Log-normal\", f = \"F-distribution\"\n    )\n    dist_name &lt;- dist_names[input$dist]\n    \n    ggplot(data.frame(x = hist_data), aes(x = x)) +\n      geom_histogram(aes(y = ..density.., fill = \"Histogram\"), bins = input$bins, color = \"black\", alpha = 0.7) +\n      stat_function(fun = switch(input$dist,\n        norm = dnorm,\n        exp = dexp,\n        gamma = dgamma,\n        unif = dunif,\n        beta = dbeta,\n        chisq = dchisq,\n        lnorm = dlnorm,\n        f = df\n      ), args = switch(input$dist,\n        norm = list(mean = input$mean, sd = input$sd),\n        exp = list(rate = input$rate),\n        gamma = list(shape = input$shape, scale = input$scale),\n        unif = list(min = input$min, max = input$max),\n        beta = list(shape1 = input$alpha, shape2 = input$beta),\n        chisq = list(df = input$df),\n        lnorm = list(meanlog = input$meanlog, sdlog = input$sdlog),\n        f = list(df1 = input$df1, df2 = input$df2)\n      ), aes(color = \"Density Curve\"), size = 1) +\n      geom_vline(aes(xintercept = mean(hist_data), color = \"Sample Mean\"), linetype = \"dotted\", size = 1.2) +\n      geom_vline(aes(xintercept = input$mean, color = \"True Mean\"), linetype = \"dashed\", size = 1.2) +\n      scale_fill_manual(values = input$hist_color, name = \"\") +  # Use selected histogram color\n      scale_color_manual(values = c(\"Density Curve\" = \"red\", \"Sample Mean\" = \"blue4\", \"True Mean\" = \"green4\"), name = \"\") +\n      labs(title = paste(dist_name, \"Distribution | Random Sample\"),\n           x = \"Value\", y = \"Density\") +\n      theme_minimal(base_size = 15) +\n      theme(\n        plot.title = element_text(hjust = 0.5),\n        legend.position = \"top\",\n        legend.title = element_blank()\n      )\n  }, res = 144)\n\n  outputOptions(output, \"plot\", suspendWhenHidden = FALSE)\n}\n\n# Create Shiny app ----\nshinyApp(ui = ui, server = server)\n\n\n\nAdditional Tips for Using ShinyLive\n\nTesting Locally: Before publishing or sharing your document, always test the Shiny app locally to ensure that it works as expected. This can help catch any issues related to missing libraries or improper configurations.\nResource Optimization: If your Shiny app is performing slowly or struggling with large datasets, consider optimizing your code by reducing the number of reactive elements or pre-processing data where possible.\nError Handling: Make sure to implement error handling within your Shiny app, especially when dealing with user inputs that could cause unexpected behavior.\n\nBy following these steps and keeping these considerations in mind, you’ll be able to effectively embed and run Shiny applications within your Quarto documents using ShinyLive. This approach allows for a seamless integration of interactive elements into your reports and presentations, providing an engaging and dynamic experience for your audience."
  }
]